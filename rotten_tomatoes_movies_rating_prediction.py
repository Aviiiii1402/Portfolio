# -*- coding: utf-8 -*-
"""Rotten Tomatoes Movies Rating Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11h-Dbw0qlFyrIXYwAvqvKN9n3i09PCAh
"""

from google.colab import files

uploaded = files.upload()

# After uploading, you can read the file using pandas
import pandas as pd
import io

movies_df = pd.read_csv(io.BytesIO(uploaded['rotten_tomatoes_movies.csv']))

movies_df.head()

# Data preprocessing I: content_rating feature
print(f'Content Rating category: {movies_df.content_rating.unique()}')

# Visualize the distribution of each category in content_rating feature
ax = movies_df.content_rating.value_counts().plot(kind='bar', figsize=(12,9))
ax.bar_label(ax.containers[0])

# One hot encoding content_rating feature
content_rating = pd.get_dummies(movies_df.content_rating).astype(int)
content_rating.head()

# Data preprocessing II: tomatometer_status feature
print(f'tomatometer_status category: {movies_df.tomatometer_status.unique()}')

# Visualize the distribution of each category in content_rating feature
ax = movies_df.tomatometer_status.value_counts().plot(kind='bar', figsize=(12,9))
ax.bar_label(ax.containers[0])

# Data preprocessing II: tomatometer_status feature
# Encode tomatometer status feature with ordinal encoding
tomatometer_status = pd.DataFrame(movies_df.tomatometer_status.replace(['Rotten','Fresh','Certified-Fresh'],[0,1,2]))
tomatometer_status

# Data preprocessing I: audience_status feature
print(f'audience_status category: {movies_df.audience_status.unique()}')

# Visualize the distribution of each category in content_rating feature
ax = movies_df.audience_status.value_counts().plot(kind='bar', figsize=(12,9))
ax.bar_label(ax.containers[0])

# Data preprocessing III: audience_status feature
# Encode audience_status feature with ordinal encoding
audience_status = pd.DataFrame(movies_df.audience_status.replace(['Upright','Spilled'],[0,1]))
audience_status

# Combine all of the features together into one dataframe
feature_df = pd.concat([movies_df[['runtime', 'tomatometer_rating', 'tomatometer_count', 'audience_rating', 'audience_count', 'tomatometer_top_critics_count', 'tomatometer_fresh_critics_count', 'tomatometer_rotten_critics_count']]
                        , content_rating, audience_status, tomatometer_status], axis=1).dropna()
feature_df.head()

# Split the data into training and test data
from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(feature_df.drop(['tomatometer_status'], axis=1), feature_df.tomatometer_status, test_size= 0.2, random_state=42)
print(f'Size of training data is {len(X_train)} and the size of test data is {len(X_test)}')

##Random Forest model##

from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import joblib  # For saving the model

# Initialize the Logistic Regression model
model = LogisticRegression(max_iter=1000)

# Train the model on the training data
model.fit(X_train, y_train)

# Predict on the validation set
y_val_pred = model.predict(X_test)

# Evaluate the model
print("Validation Accuracy:", accuracy_score(y_test, y_val_pred))
print("\nClassification Report:\n", classification_report(y_test, y_val_pred))
print("\nConfusion Matrix:\n", confusion_matrix(y_test, y_val_pred))

# Save the trained model
joblib.dump(model, 'logistic_regression_model.pkl')
print("Model saved as logistic_regression_model.pkl")

##Random Forest model##

from sklearn.ensemble import RandomForestClassifier
# Initialize the Random Forest model
model_rf = RandomForestClassifier(n_estimators=100, random_state=42)

# Train the model
model_rf.fit(X_train, y_train)

# Predict on the test set
y_val_pred_rf = model_rf.predict(X_test)

# Evaluate the model
print("Validation Accuracy (Random Forest):", accuracy_score(y_test, y_val_pred_rf))
print("\nClassification Report (Random Forest):\n", classification_report(y_test, y_val_pred_rf))
print("\nConfusion Matrix (Random Forest):\n", confusion_matrix(y_test, y_val_pred_rf))

# Save the trained model
joblib.dump(model_rf, 'random_forest_model.pkl')
print("Model saved as random_forest_model.pkl")

##XG BOOST model##
import pandas as pd
import xgboost as xgb
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import joblib

# Initialize the XGBoost model
model_xgb = xgb.XGBClassifier(objective='binary:logistic', use_label_encoder=False, eval_metric='logloss')

# Train the model
model_xgb.fit(X_train, y_train)

# Predict on the test set
y_val_pred_xgb = model_xgb.predict(X_test)

# Evaluate the model
print("Validation Accuracy (XGBoost):", accuracy_score(y_test, y_val_pred_xgb))
print("\nClassification Report (XGBoost):\n", classification_report(y_test, y_val_pred_xgb))
print("\nConfusion Matrix (XGBoost):\n", confusion_matrix(y_test, y_val_pred_xgb))

# Save the trained model
joblib.dump(model_xgb, 'xgboost_model.pkl')
print("Model saved as xgboost_model.pkl")

